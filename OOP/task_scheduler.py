from abc import ABC, abstractmethod
from collections import deque
from typing import Callable, Any

Task = Callable[..., Any]


class AbstractScheduler(ABC):
    @abstractmethod
    def schedule(self, task: Task, priority: int) -> None:
        pass

    @abstractmethod
    def exec(self, *args) -> Any:
        pass

    @abstractmethod
    def exec_and_finish(self, *args) -> Any:
        pass


class Scheduler(AbstractScheduler):
    __instance = None
    __is_initialized = False

    def __new__(cls, *args):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        
        return cls.__instance
    
    def __init__(self, n: int):
        if self.__is_initialized:
            return
  
        self.__n = n
        self.__queues = [deque() for _ in range(n)]  # Creates FIFO
        self.__is_initialized = True
        self.__execution_counts = [0] * n

    def schedule(self, task: Task, priority: int):
        if not callable(task):
            raise ValueError("Task must be a function!")
        
        if priority < 0 or priority >= self.__n:
            raise ValueError("Invalid priority!")
        
        self.__queues[priority].append(task)
        
    def exec(self, *args) -> Any: # This function was inspired by code generated by DeepSeek AI
        for priority in range(self.__n):
            # Calculate the number of times this priority should be executed
            max_executions = self.__n - priority
            if self.__execution_counts[priority] < max_executions:
                queue = self.__queues[priority]
                if queue:
                    task = queue.popleft()
                    try:
                        result = task(*args)
                        queue.append(task)  # Requeue the task
                        self.__execution_counts[priority] += 1
                        return result
                    except Exception as e:
                        queue.appendleft(task)  # Requeue the task if it fails
                        raise e

        # Reset execution counts if all priorities have been executed enough times
        self.__execution_counts = [0] * self.__n
        return self.exec(*args)  # Try again
    
    def exec_and_finish(self, *args):
        for priority in range(self.__n):
            # Calculate the number of times this priority should be executed
            max_executions = self.__n - priority
            if self.__execution_counts[priority] < max_executions:
                queue = self.__queues[priority]
                if queue:
                    task = queue.popleft()
                    try:
                        result = task(*args)
                        self.__execution_counts[priority] += 1
                        return result
                    except Exception as e:
                        queue.appendleft(task)  # Requeue the task if it fails
                        raise e

        self.__execution_counts = [0] * self.__n
        return self.exec_and_finish(*args)  # Try again

    def class_count(self):
        return self.__n

    def task_count(self):
        return sum(len(queue) for queue in self.__queues)

sch1 = Scheduler(2)
sch2 = Scheduler(1)

print(sch1 is sch2)     # True

sch1.schedule(lambda: "Idle task", 0)
print(sch2.exec())     # Idle task
print(sch1.exec())     # Idle task

sch1.schedule(lambda: "Hello World", 1)
print(sch2.exec())     # Hello World
print(sch1.exec())     # Idle task
print(sch2.exec())     # Idle task
print(sch2.exec())     # Hello World

'''
from abc import ABC, abstractmethod
from collections import deque
from typing import Callable, Any
  
  
Task = Callable[..., Any]
  
  
class AbstractScheduler(ABC):
    @abstractmethod
    def schedule(self, task: Task, priority: int) -> None:
        pass
  
    @abstractmethod
    def exec(self, *args) -> Any:
        pass
  
    @abstractmethod
    def exec_and_finish(self, *args) -> Any:
        pass
  
  
class Scheduler(AbstractScheduler):
    __instance = None
    __is_initialized = False
  
    def __new__(cls, *args):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        return cls.__instance
    
    def __init__(self, n: int):
        if Scheduler.__is_initialized:
            return
  
        self._n_classes = n
        self._queues: list[deque[Task]] = [deque() for _ in range(n)]
        self._n_tasks = 0
  
        self.__curr_class = 0
        self.__execed_count = 0
  
        Scheduler.__is_initialized = True
  
    def class_count(self) -> int:
        return self._n_classes
  
    def task_count(self) -> int:
        return self._n_tasks
  
    def schedule(self, task: Task, priority: int) -> None:
        if not callable(task):
            raise ValueError("The given task is not callable")
  
        if not (0 <= priority < self._n_classes):
            raise ValueError("Invalid task priority")
        
        self._queues[priority].append(task)
        self._n_tasks += 1
  
    def _exec_next(self, reschedule: bool, *args) -> Any:
        if self._n_tasks == 0:
            raise IndexError("No tasks scheduled")
  
        while True:
            queue = self._queues[self.__curr_class]
            if len(queue) != 0:
                break
  
            self.__curr_class += 1
            self.__curr_class %= self._n_classes
            self.__execed_count = 0
        
        task = queue.popleft()
        if reschedule:
            queue.append(task)
  
        self.__execed_count += 1
        class_incr = int(self.__execed_count == self._n_classes - self.__curr_class)
        self.__execed_count %= self._n_classes - self.__curr_class
        self.__curr_class += class_incr
        self.__curr_class %= self._n_classes
  
        return task(*args)
  
    def exec(self, *args) -> Any:
        return self._exec_next(True, *args)
  
    def exec_and_finish(self, *args) -> Any:
        result = self._exec_next(False, *args)
        self._n_tasks -= 1
        return result
'''